<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MinefieldPanel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java-minesweeper-master</a> &gt; <a href="index.source.html" class="el_package">uk.ac.york.minesweeper</a> &gt; <span class="el_source">MinefieldPanel.java</span></div><h1>MinefieldPanel.java</h1><pre class="source lang-java linenums">package uk.ac.york.minesweeper;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

import javax.swing.JComponent;
import javax.swing.SwingUtilities;

/**
 * A component which can display a minefield graphically and handle various events
 */
public class MinefieldPanel extends JComponent
{
    private static final long serialVersionUID = 1L;

    /** Size of all the tiles */
    private static final int TILE_SIZE = 32;

    /** Width of the bevel */
    private static final int BEVEL_WIDTH = 2;

    /** Font vertical offset (from top to BASELINE) */
    private static final int FONT_VOFFSET = 24;

    /** The font to draw numbers with */
<span class="nc" id="L35">    private static final Font FONT = new Font(Font.MONOSPACED, Font.BOLD, 24);</span>


    /** Default background colour */
<span class="nc" id="L39">    private static final Color COLOUR_BACKGROUND = new Color(0xC0, 0xC0, 0xC0);</span>

    /** Light grey for bevels */
<span class="nc" id="L42">    private static final Color COLOUR_LIGHT = new Color(0xE0, 0xE0, 0xE0);</span>

    /** Dark grey for bevels */
<span class="nc" id="L45">    private static final Color COLOUR_DARK = new Color(0x80, 0x80, 0x80);</span>

    /** Colour of question marks */
<span class="nc" id="L48">    private static final Color COLOUR_QUESTION = Color.WHITE;</span>

    /** The colours of the numbers (0 is unused) */
<span class="nc" id="L51">    private static final Color[] COLOUR_NUMBERS = new Color[]</span>
    {
        null,                           // 0 = Unused
        new Color(0x00, 0x00, 0xFF),    // 1 = Blue
        new Color(0x00, 0x7F, 0x00),    // 2 = Green
        new Color(0xFF, 0x00, 0x00),    // 3 = Red
        new Color(0x2F, 0x2F, 0x9F),    // 4 = Dark Blue
        new Color(0x7F, 0x00, 0x00),    // 5 = Maroon
        new Color(0x9F, 0x9F, 0x2F),    // 6 = Turquoise
        new Color(0x00, 0x00, 0x00),    // 7 = Black
        new Color(0x7F, 0x7F, 0x7F),    // 8 = Grey
    };

    /** Current minefield */
    private Minefield minefield;

    /** Currently selected tile (null most of the time) */
    private Point selectedTile;

    /** List of state change listeners */
<span class="nc" id="L71">    private ArrayList&lt;MinefieldStateChangeListener&gt; listeners = new ArrayList&lt;MinefieldStateChangeListener&gt;();</span>

    /**
     * Initializes a new MinefieldPanel with the given Minefield
     *
     * There must always be a minefield to display (you cannot pass null)
     *
     * @param minefield minefield to display
     */
    public MinefieldPanel(Minefield minefield)
<span class="nc" id="L81">    {</span>
<span class="nc" id="L82">        this.addMouseListener(new MouseEventListener());</span>
<span class="nc" id="L83">        this.setBackground(COLOUR_BACKGROUND);</span>
<span class="nc" id="L84">        this.setOpaque(true);</span>
<span class="nc" id="L85">        this.setFont(FONT);</span>
<span class="nc" id="L86">        this.setMinefield(minefield);</span>
<span class="nc" id="L87">    }</span>

    /**
     * Adds a listener to which received game state change events
     *
     * @param listener listener to add
     */
    public void addStateChangeListener(MinefieldStateChangeListener listener)
    {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (!listeners.contains(listener))</span>
<span class="nc" id="L97">            listeners.add(listener);</span>
<span class="nc" id="L98">    }</span>

    /**
     * Removes a listener which received game state change events
     *
     * @param listener listener to remove
     */
    public void removeStateChangeListener(MinefieldStateChangeListener listener)
    {
<span class="nc" id="L107">        listeners.remove(listener);</span>
<span class="nc" id="L108">    }</span>

    /**
     * Fires the state changed event
     */
    private void fireStateChangeEvent()
    {
<span class="nc" id="L115">        MinefieldStateChangeEvent event = new MinefieldStateChangeEvent(this);</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        for (MinefieldStateChangeListener listener : listeners)</span>
<span class="nc" id="L118">            listener.stateChanged(event);</span>
<span class="nc" id="L119">    }</span>

    /**
     * Gets the current minefield
     *
     * @return current minefield
     */
    public Minefield getMinefield()
    {
<span class="nc" id="L128">        return minefield;</span>
    }

    /**
     * Sets a new minefield for the component
     *
     * @param newMinefield the new minefield
     */
    public void setMinefield(Minefield newMinefield)
    {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (newMinefield == null)</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;newMinefield cannot be null&quot;);</span>

<span class="nc" id="L141">        this.minefield = newMinefield;</span>

        // Reset selected tile
<span class="nc" id="L144">        this.selectedTile = null;</span>

        // Update all visuals
<span class="nc" id="L147">        this.setSize(getPreferredSize());</span>
<span class="nc" id="L148">        this.repaint();</span>

        // Fire event
<span class="nc" id="L151">        this.fireStateChangeEvent();</span>
<span class="nc" id="L152">    }</span>

    /**
     * Draws a character on a tile
     *
     * @param g graphics object
     * @param x x position of top-left of tile
     * @param y y position of top-left of tile
     * @param c character to draw
     */
    private static void drawCharacter(Graphics g, int x, int y, char c)
    {
        // Get coordinates to draw at
<span class="nc" id="L165">        int drawX = x + (TILE_SIZE - g.getFontMetrics().charWidth(c)) / 2;</span>
<span class="nc" id="L166">        int drawY = y + FONT_VOFFSET;</span>

        // Draw the character
<span class="nc" id="L169">        g.drawChars(new char[] { c }, 0, 1, drawX, drawY);</span>
<span class="nc" id="L170">    }</span>

    /**
     * Draws an image at the given tile location
     *
     * @param g graphics object
     * @param x x position of top-left of tile
     * @param y y position of top-left of tile
     * @param img image to draw
     */
    private static void drawImage(Graphics g, int tileX, int tileY, BufferedImage img)
    {
<span class="nc" id="L182">        int xOff = tileX + (TILE_SIZE - img.getWidth()) / 2;</span>
<span class="nc" id="L183">        int yOff = tileY + (TILE_SIZE - img.getHeight()) / 2;</span>

<span class="nc" id="L185">        g.drawImage(img, xOff, yOff, null);</span>
<span class="nc" id="L186">    }</span>

    @Override
    public void paintComponent(Graphics gOld)
    {
<span class="nc" id="L191">        Graphics2D g = (Graphics2D) gOld;</span>

        // Get selected tile position
<span class="nc bnc" id="L194" title="All 2 branches missed.">        int selectedX = (selectedTile == null ? -1 : selectedTile.x);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        int selectedY = (selectedTile == null ? -1 : selectedTile.y);</span>

        // Make the numbers look a little nicer
<span class="nc" id="L198">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>

        // Draw background
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (isOpaque())</span>
        {
<span class="nc" id="L203">            g.setColor(getBackground());</span>
<span class="nc" id="L204">            g.fillRect(0, 0, getWidth(), getHeight());</span>
        }

        // Draw all the tiles
<span class="nc bnc" id="L208" title="All 2 branches missed.">        for (int x = 0; x &lt; minefield.getWidth(); x++)</span>
        {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            for (int y = 0; y &lt; minefield.getHeight(); y++)</span>
            {
<span class="nc" id="L212">                int graphicsX1 = x * TILE_SIZE;</span>
<span class="nc" id="L213">                int graphicsY1 = y * TILE_SIZE;</span>

                // Draw standard background
<span class="nc" id="L216">                g.setColor(COLOUR_DARK);</span>
<span class="nc" id="L217">                g.drawLine(graphicsX1, graphicsY1, graphicsX1 + TILE_SIZE, graphicsY1);</span>
<span class="nc" id="L218">                g.drawLine(graphicsX1, graphicsY1, graphicsX1, graphicsY1 + TILE_SIZE);</span>

                // Covered or uncovered?
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (minefield.getTileState(x, y) == TileState.UNCOVERED)</span>
                {
                    // Draw the correct symbol
<span class="nc" id="L224">                    int tileValue = minefield.getTileValue(x, y);</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">                    if (tileValue &lt; 0)</span>
                    {
<span class="nc" id="L228">                        drawImage(g, graphicsX1, graphicsY1, Images.MINE);</span>
                    }
<span class="nc bnc" id="L230" title="All 2 branches missed.">                    else if (tileValue &gt; 0)</span>
                    {
<span class="nc" id="L232">                        g.setColor(COLOUR_NUMBERS[tileValue]);</span>
<span class="nc" id="L233">                        drawCharacter(g, graphicsX1, graphicsY1, (char) ('0' + tileValue));</span>
                    }
<span class="nc" id="L235">                }</span>
                else
                {
                    // Only draw the bevel background if this is NOT the selected tile
<span class="nc bnc" id="L239" title="All 4 branches missed.">                    if (x != selectedX || y != selectedY)</span>
                    {
<span class="nc" id="L241">                        int bevelX2 = graphicsX1 + TILE_SIZE - BEVEL_WIDTH;</span>
<span class="nc" id="L242">                        int bevelY2 = graphicsY1 + TILE_SIZE - BEVEL_WIDTH;</span>

<span class="nc" id="L244">                        g.setColor(COLOUR_LIGHT);</span>
<span class="nc" id="L245">                        g.fillRect(graphicsX1, graphicsY1, TILE_SIZE, BEVEL_WIDTH);</span>
<span class="nc" id="L246">                        g.fillRect(graphicsX1, graphicsY1, BEVEL_WIDTH, TILE_SIZE);</span>
<span class="nc" id="L247">                        g.setColor(COLOUR_DARK);</span>
<span class="nc" id="L248">                        g.fillRect(graphicsX1, bevelY2,    TILE_SIZE, BEVEL_WIDTH);</span>
<span class="nc" id="L249">                        g.fillRect(bevelX2,    graphicsY1, BEVEL_WIDTH, TILE_SIZE);</span>
                    }

                    // Draw flag or question mark if needed
<span class="nc bnc" id="L253" title="All 2 branches missed.">                    if (minefield.getTileState(x, y) == TileState.FLAGGED)</span>
                    {
<span class="nc" id="L255">                        drawImage(g, graphicsX1, graphicsY1, Images.FLAG);</span>
                    }
<span class="nc bnc" id="L257" title="All 2 branches missed.">                    else if (minefield.getTileState(x, y) == TileState.QUESTION)</span>
                    {
<span class="nc" id="L259">                        g.setColor(COLOUR_QUESTION);</span>
<span class="nc" id="L260">                        drawCharacter(g, graphicsX1, graphicsY1, '?');</span>
                    }
                }
            }
        }
<span class="nc" id="L265">    }</span>

    @Override
    public Dimension getPreferredSize()
    {
<span class="nc" id="L270">        return new Dimension(TILE_SIZE * minefield.getWidth(),</span>
<span class="nc" id="L271">                             TILE_SIZE * minefield.getHeight());</span>
    }

    @Override
    public Dimension getMaximumSize()
    {
<span class="nc" id="L277">        return getPreferredSize();</span>
    }

    @Override
    public Dimension getMinimumSize()
    {
<span class="nc" id="L283">        return getPreferredSize();</span>
    }

    /**
     * Handles all mouse events within the game area
     */
<span class="nc" id="L289">    private class MouseEventListener extends MouseAdapter</span>
    {
        /**
         * Calculates the selected tile from a mouse event
         */
        private Point getTileFromEvent(MouseEvent e)
        {
<span class="nc" id="L296">            return new Point(e.getX() / TILE_SIZE, e.getY() / TILE_SIZE);</span>
        }

        @Override
        public void mouseExited(MouseEvent e)
        {
            // Clear selected tile
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (selectedTile != null)</span>
            {
<span class="nc" id="L305">                selectedTile = null;</span>
<span class="nc" id="L306">                repaint();</span>
            }
<span class="nc" id="L308">        }</span>

        @Override
        public void mousePressed(MouseEvent e)
        {
            // Ignore if finished
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (minefield.isFinished())</span>
<span class="nc" id="L315">                return;</span>

            // Get tile position
<span class="nc" id="L318">            Point tile = getTileFromEvent(e);</span>

            // Right or left click?
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (SwingUtilities.isLeftMouseButton(e))</span>
            {
                // Do not select tiles with flags on
<span class="nc bnc" id="L324" title="All 2 branches missed.">                if (minefield.getTileState(tile.x, tile.y) == TileState.FLAGGED)</span>
<span class="nc" id="L325">                    return;</span>

                // Set new selected tile
<span class="nc" id="L328">                selectedTile = tile;</span>
            }
<span class="nc bnc" id="L330" title="All 2 branches missed.">            else if (SwingUtilities.isRightMouseButton(e))</span>
            {
                TileState newState;

                // Change flagged state
<span class="nc bnc" id="L335" title="All 4 branches missed.">                switch(minefield.getTileState(tile.x, tile.y))</span>
                {
<span class="nc" id="L337">                    case COVERED:   newState = TileState.FLAGGED;   break;</span>
<span class="nc" id="L338">                    case FLAGGED:   newState = TileState.QUESTION;  break;</span>
<span class="nc" id="L339">                    default:        newState = TileState.COVERED;   break;</span>

<span class="nc" id="L341">                    case UNCOVERED: newState = TileState.UNCOVERED; break;</span>
                }

<span class="nc" id="L344">                minefield.setTileState(tile.x, tile.y, newState);</span>
            }

<span class="nc" id="L347">            repaint();</span>
<span class="nc" id="L348">        }</span>

        @Override
        public void mouseReleased(MouseEvent e)
        {
            // Ignore if finished
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (minefield.isFinished())</span>
<span class="nc" id="L355">                return;</span>

            // Ensure there was a tile selected
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (selectedTile != null)</span>
            {
                // Ensure the tile was the same as the one clicked on
<span class="nc bnc" id="L361" title="All 2 branches missed.">                if (selectedTile.equals(getTileFromEvent(e)))</span>
                {
                    // Either chord or uncover depending on the number of clicks
<span class="nc" id="L364">                    GameState state = minefield.getGameState();</span>

<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (e.getClickCount() == 2)</span>
<span class="nc" id="L367">                        minefield.chord(selectedTile.x, selectedTile.y);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    else if (e.getClickCount() == 1)</span>
<span class="nc" id="L369">                        minefield.uncover(selectedTile.x, selectedTile.y);</span>

                    // Fire state changed event if needed
<span class="nc bnc" id="L372" title="All 2 branches missed.">                    if (minefield.getGameState() != state)</span>
<span class="nc" id="L373">                        fireStateChangeEvent();</span>
                }

                // Clear selected tile
<span class="nc" id="L377">                selectedTile = null;</span>
<span class="nc" id="L378">                repaint();</span>
            }
<span class="nc" id="L380">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>